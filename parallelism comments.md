> Is this video intended for a general audience or those who are familiar with FBP? For e.g. at [0:45](https://www.youtube.com/watch?v=JD8QpV-t5eM&t=0m45s), the concepts of port have meaning only to those who know FBP? Should we be talking about the send/recv primitives? to show how a component sends data. if a component does send data to a port, how does that go to another component? FBP is nice to show even as diagrams to explain data passing between two unit components?

I'm arguing with myself about how to combat TL;DR.  When I shorten a note for quick consumption, I have to leave some details out.

> At [0:33](https://www.youtube.com/watch?v=JD8QpV-t5eM&t=0m33s), "components can return a value to the caller", for those of us initially only familiar into the concept of synchronous function calls, we may not understand how it's done. I guess you are talking about wiring plus the send() primitive?

 Yes.
 
 "x | f | g" instead of "f(g(x))".  "x" is SENt to "f" and the value generated by "f" is SENt to "g".  We're so accustomed to function-call textual syntax that we tend not to see that it breaks down into lower-level operations. It is certainly possible to alter the syntax of function calls to look more like "x | f | g".  How do you express the idea that "x | f" SENDs a value to "g" -and- SENDs the same value, also, to "h"?  I haven't seen a textual syntax that conveniently expresses this kind of thing, but, it is easy to draw on a whiteboard. When all you have is functions, everything looks like CALL/RETURN, and, we tend not to even THINK of the possibility of SENDing results to more than 1 place (or 0 places). Example: we write software that allows A,B, and C to collaborate p2p.  If we insist on using function-call syntax, then we have to create an epicycle-dance to transmit any change made by A to B and to C. If, though, we use SEND instead of CALL/RETURN, we can express this situation easily.

SEND is one-way only "from here to there", whereas CALL/RETURN is two-way "from here to there and back again".  CALL/RETURN is composed of two SENDs.
 
Yes.  "Call/Return" is an edge-case IMO.  CALL f(x) is the same as SEND'ing "x" to "f" and the subesquent "RETURN" is the same as the callee SEND'ing a return value to the caller.  CALL/RETURN can be implemented more atomically as 2 SEND()s.  CALL/RETURN nails down the target of each SEND, but, SEND can do more if the targets are not nailed down.  An example would be a simple left-to-right pipeline.  The left-most component SENDs something to the next component to the right and doesn't NEED to wait for a result.  That component might SEND a value to the component on its right and not send anything back leftwards.  "CALL/RETURN" requires that each component SEND a return value back leftwards and the code needs to jump through hoops to capture the results and CALL the next components in the pipeline.  UNIX /bin/sh syntax has no problem specifying this, but function call syntax requires programmers to employ epicycles (for example, nested Lambdas, or inverting the pipeline to be inside-first-then-out). 
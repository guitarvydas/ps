Too much detail is as bad as too little detail, when debugging.

All of the details are needed to make something work, but, the details need to be elided (in layers).

For example, compilers help us because they elide the details of cod written in assembler.  We get to think at a "higher level", i.e. at the level of the language.  Yet, all of the details are there - the compiler inserts the details and hides the from us.

For example, when a program *throws* an error, the dump usually includes a wall of detail, which obfuscates the true purpose of what is being debugged.  This is what happened in the mid-1900s with *core dumps*.  I.e. *throw* is a poor substitute for error messages generated by an application.

The big wins in computer science have involved eliding details, such as:
- structured programming
- garbage collection
- lambdas
- scoping
- packaging
- etc.

## Structured Programming
- structured programming suggests wrapping GOTOful code in neater bundles that leaks less
- ironically, modern languages break the tenets of structured programming by allowing exceptions (syntax that provides more than one exit point for a routine)

## Garbage Collection
- elided memory management details
- prior to GC, programmers used *malloc()* and managed memory manually
- ironically, GC was invented soon after FORTRAN was invented (in Lisp, around 1956), but didn't make it into the mainstream until Java popularized the concept

## Lambdas
- lambdas were invented in Lisp around 1956
- lambdas wrap functionality with local parameters

## Scoping
- the global variable problem was defeated by the invention of scopes and placing variables into localized scopes

## Packaging
- the namespace problem is being attacked by packages (namespaces)
- namespaces (packages) create even more scopes which elide names (details) except those which are *exported*



# Divide-and-conquer applied to Programming
1. Develop Ideas, Implement and Explore and Debug Ideas (FoC)
2. Production Engineer to optimize step (1) to run on cheaper hardware (PoC) 

## Discussion
1 => use "dynamic languages" to explore FoC ideas (e.g. Lisp, Smalltalk, etc.)

2 => use “static languages" to optimize ideas (e.g. Python, Haskell, Rust, etc.)

[Yes, writing the Code twice is more efficient than writing it only once in a PoC language].

## FoC vs PoC
FoC ≣ Future of Coding

PoC ≣ Present of Coding

# Conclusion
I am concluding 
- that divide-and-conquer can be applied to the act of Programming, and,
- that FoC should be done with "dynamic languages" (Lisp (pre-CL), JavaScript, REBOL, Self, etc.).  PoC (Present of Coding) languages, e.g. "static languages" like Haskell, Rust, C++, etc., and, compilation-appeasement dynamic languages like Python, Racket, Scheme, Smalltalk, Common Lisp, etc., are used to optimize and structure FoC ideas, but, they stunt out-of-the-box-thinking-like-FoC.  

I include Smalltalk and CL, mostly because they use Classes instead of Prototypes.

All programming languages currently suffer from over-use of synchronization (LIFOs instead of FIFOs) (call stack = LIFO).

Anything that imposes premature-structuring done "someone else's way" inhibits FoC-style out of the box thinking.
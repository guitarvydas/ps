# Concurrency

Concurrency surrounds us in daily life.

Everything we do, everything we are accustomed to, is concurrent - cooking recipes, piano lessons, interaction with other people, business, etc., etc.

Yet, we try to control computers using only *synchronous* languages.

On single-CPU systems, we can only *simulate* concurrency.

The simulations are wrought with epicycles.

We have invented a myriad of clever solutions for using the epicycle-ridden simulations.

We need serious distributed programming, e.g. IoT, blockchain, internet, etc.

I contend that we should approach computers as asynchronous - concurrent - *things* and that we should program them that way.

The StateCharts paper showed me that diagrams of programs made more sense for concurrent programming than did our synchronous-only based approaches.

In fact, once I had "easy to use" concurrency, it became possible to draw other kinds of diagrams of programs.

See, also, [Rob Pike's Concurrency is not Parallelism](https://www.youtube.com/watch?v=oV9rvDllKEg).


#statecharts 

inspired by [Live Workshop 2022 Announcement](http://liveprog.org)

-   Live. Live programming systems ...
	- Live used to be called REPL
	- Programming is about controlling a machine using any means available
	- Textual Programming Languages are only a subset of programming.
-   Structured. A program is highly structured and meaningful to the programmer, even in traditionally invalid states. “Structure-aware” programming environments...
	- bad idea
	- editors should edit
	- leave parsing, understanding ("semantics") to later passes not bolted into editor
-   Tangible. ...
	- A Slider widget is just a better version of a command line.
-   Concrete. People find it easier to start with concrete examples and generalise afterwards....
	- Snapping software together requires 0D (zero dependency).  
	- Current PLs are synchronous and cause hidden dependencies.  
	- Current PLs use LIFOs (e.g. call stack).
	- FIFOs support asynchronous operation
		- easy to implement, drop messages into FIFOs instead of calling functions

-   live programming environments
	- AKA REPL with visual syntax
-   visual programming
	- Programming is more than text
	- Text languages do not parse full prose
		- Visual language do not need to parse general ART, just technical diagrams (AKA construction blueprints)
-   structure-aware editors
	- bad idea
	- users should be allowed to create illegal programs
		- structure-aware editors inhibit Creation and Design and successive refinement
		- IMO best mind-mapping apps are Scapple and Kinopio - no artifical constraints ; most mind-mapping software is cumbersome and too structured
		- Ohm / PEG give a new lease on syntax (syntax is cheap)
			- create a very low-level library of operations
			- drape syntax skins over phrases of operations
-   advances in REPLs, notebooks, and playgrounds
-   programming with typed holes, interactive programming
-   programming by example/demonstration
	- PROLOG, miniKanren, Barliman
-   bidirectional programming
	- ???
	- it used to be possible to see the assembler generated by C programs, now, no one bothers to look
-   debugging and execution visualization techniques
	- debugging == iteration of Design
	- main feature is support for "changing your mind"
-   language learning environments
-   alternative language semantics or paradigms in support of the above
	- async software components with Ports
	- (Parameter Lists and Functions imply sync software)
-   theoretical frameworks for characterising technical or experiential properties of live programming

0D:
- unbounded buffers for IPC
	- bounding implies preemption devolves to sync
- Parent gets first dibs, Child cannot override Parent decisions
- 
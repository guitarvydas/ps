This pure-function/state-machine duality is evident when functional notation is implemented on present-day electronic computers.

As it is, functional notation restricts programming to that of programming *calculators*.

Functional notation has been forced to express other kinds of programming, e.g. *sequencers*, but, functional notation is pushed out of its *comfort zone*, and, various tricks need to be employed, e.g. full preemption, threads, etc.

This lack of expressivity indicates that other notations need to be used for covering the full gamut of electronic computer capabilities.
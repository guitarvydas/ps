Jack Rusher made a good point about convenient debugging.  [discord comments](https://twitter.com/jackrusher/status/1558000856263540736):

Riffing on this idea: too long to paste here, so I've written it in Obsidian instead https://publish.obsidian.md/programmingsimplicity/2022-08-12-Convenient+Programming+IDEs

---

I am concluding (a) that divide-and-conquer can be applied to Programming and (b) that FoC should be done with "dynamic languages" (Lisp (pre-CL), JavaScript, REBOL, Self, etc.).  PoC (Present of Coding) languages, e.g. "static languages" like Haskell, Rust, C++, etc., and, compilation-appeasement dynamic languages like Python, Racket, Scheme, Smalltalk, Common Lisp, etc., are used to optimize and structure FoC ideas, but, they stunt out-of-the-box-thinking-like-FoC.  (I include Smalltalk and CL, mostly because they use Classes instead of Prototypes). (All programming languages currently suffer from over-use of synchronization (LIFOs instead of FIFOs) (call stack = LIFO))

---

Jack Rusher made a good point about convenient debugging.

I indulged in riffing on this idea: too long to paste here, so I've written it in Obsidian instead https://publish.obsidian.md/programmingsimplicity/2022-08-12-Convenient+Programming+IDEs

---
For discussion: I am thinking that FoC should be done with "dynamic languages" (Lisp (pre-CL), JavaScript, REBOL, Self, technical diagrams, etc.).  PoC (Present of Coding) languages, e.g. "static languages" like Haskell, Rust, C++, etc., and, compiler-appeasement dynamic languages like Python, Racket, Scheme, Smalltalk, Common Lisp, etc., are used to optimize and to structure FoC ideas, but, they inhibit out-of-the-box-thinking.  Writing the program twice (or more times) is more efficient than writing the code once only in a PoC language.  What is "efficient"?  At one extreme: all Design and no optimization, at the other extreme: all Production Engineering (optimization) and no Design.